{
    "sourceFile": "simulation_scripts/TSMCController.m",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 202,
            "patches": [
                {
                    "date": 1729819406605,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1729819563406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+%Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15) \r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+%K=tril(ones(6));\r\n+beta = 1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+alpha =  diag([500;500;500;500;500;500]);\r\n+eposlion=10;\r\n+% ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n+ctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n+ %phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym,t_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+he=sym(500*0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+%he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n+%\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+ctrl.v=@(t,q,p) (-inv(dphidep(p,t))*Lambda(q,p,t)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p,t))*dphideq(q,t))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+%ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+%ctrl.v=@(t,q,p) zeros(6,1);\r\n+%input u from eq.(20)\r\n+ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p));\r\n+\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729820272035,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n %K=tril(ones(6));\r\n beta = 1;\r\n gamma = 3;\r\n delta = 1;\r\n-alpha =  diag([500;500;500;500;500;500]);\r\n+alpha =  diag([50000;50000;50000;50000;50000;50000]);\r\n eposlion=10;\r\n % ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n ctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n  %phi=@(q,p) K*q+tan(p);\r\n@@ -43,9 +43,9 @@\n dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n-he=sym(500*0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+he=sym(0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n %he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\n Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n %\r\n %Compute the partial derivative of U\r\n@@ -61,65 +61,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15) \r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n-%K=tril(ones(6));\r\n-beta = 1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-alpha =  diag([500;500;500;500;500;500]);\r\n-eposlion=10;\r\n-% ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n-ctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n- %phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym,t_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-he=sym(500*0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-%he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n-%\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-ctrl.v=@(t,q,p) (-inv(dphidep(p,t))*Lambda(q,p,t)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p,t))*dphideq(q,t))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-%ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-%ctrl.v=@(t,q,p) zeros(6,1);\r\n-%input u from eq.(20)\r\n-ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p));\r\n-\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729820354811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,12 +29,12 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n %K=tril(ones(6));\r\n-beta = 1;\r\n+beta = 500000;\r\n gamma = 3;\r\n delta = 1;\r\n-alpha =  diag([50000;50000;50000;50000;50000;50000]);\r\n+alpha =  diag([500000;500000;500000;500000;500000;500000]);\r\n eposlion=10;\r\n % ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n ctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n  %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1729820547869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,12 +29,12 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n %K=tril(ones(6));\r\n-beta = 500000;\r\n+beta = 100000;\r\n gamma = 3;\r\n delta = 1;\r\n-alpha =  diag([500000;500000;500000;500000;500000;500000]);\r\n+alpha =  diag([100000;100000;100000;100000;100000;100000]);\r\n eposlion=10;\r\n % ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n ctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n  %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1729838658903,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,96 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15) \r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+%K=tril(ones(6));\r\n+beta = 10000;\r\n+gamma = 3;\r\n+delta = 1;\r\n+alpha =  diag([50000;50000;50000;50000;50000;50000]);\r\n+ K2=diag([500;500;500;500;500;300]);\r\n+eposlion=10;\r\n+% ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n+ctrl.phi = @(t,q,p) K2*ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n+ %phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq=matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep=matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   K3 = diag([5;5;5;5;5;5]);\r\n+    % K3 = diag([0;0;0;0;0;0]);\r\n+  Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n+\r\n+he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+ % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n+\r\n+\r\n+\r\n+\r\n+% dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym,t_sym});\r\n+% dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n+% %Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+% %compute the Lambda from eq.(22)\r\n+% he=sym(0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+% %he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\n+% Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n+% %\r\n+% %Compute the partial derivative of U\r\n+% normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+% %Then the feedback controller from eq.(23)\r\n+% ctrl.v=@(t,q,p) (-inv(dphidep(p,t))*Lambda(q,p,t)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p,t))*dphideq(q,t))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+% %ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+% %ctrl.v=@(t,q,p) zeros(6,1);\r\n+% %input u from eq.(20)\r\n+% ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p));\r\n+\r\n+% % Define  closed-loop energy in eq.(24)\r\n+% ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+% ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+% ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729840174807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,20 +7,20 @@\n syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n q_sym = [q1 q2 q3 q4 q5 q6].';\r\n p_sym = [p1 p2 p3 p4 p5 p6].';\r\n \r\n-\r\n ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n \r\n ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n ctrl.D = @(q) sys.D(q);\r\n ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n \r\n % Compute the target momentum from (13)\r\n %期望动量的坐标变换\r\n ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n \r\n-% Compute the error coordinates on q, p from (11), (15) \r\n+% Compute the error coordinates on q, p from (11), (15)\r\n %速度和动量误差\r\n ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n % Compute the gradient of the reference momentum with respect to\r\n@@ -28,21 +28,19 @@\n %求期望动量的梯度\r\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n-%K=tril(ones(6));\r\n-beta = 10000;\r\n+ %K=tril(ones(6));\r\n+ K=diag([500000;500000;500000;500000;500000;500000]);\r\n+ K2=diag([500;500;500;500;500;300]);\r\n+beta = 100000;\r\n gamma = 3;\r\n delta = 1;\r\n-alpha =  diag([50000;50000;50000;50000;50000;50000]);\r\n- K2=diag([500;500;500;500;500;300]);\r\n-eposlion=10;\r\n-% ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n-ctrl.phi = @(t,q,p) K2*ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n- %phi=@(q,p) K*q+tan(p);\r\n+ctrl.phi=@(t,q,p) K*ctrl.eq(t,q)+K2*ctrl.ep(t,q,p)+ beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n %Take a partial derivative of \\phi\r\n-dphideq=matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep=matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n    K3 = diag([5;5;5;5;5;5]);\r\n@@ -66,95 +64,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-\r\n-\r\n-\r\n-\r\n-% dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym,t_sym});\r\n-% dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n-% %Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-% %compute the Lambda from eq.(22)\r\n-% he=sym(0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-% %he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\n-% Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n-% %\r\n-% %Compute the partial derivative of U\r\n-% normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-% %Then the feedback controller from eq.(23)\r\n-% ctrl.v=@(t,q,p) (-inv(dphidep(p,t))*Lambda(q,p,t)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p,t))*dphideq(q,t))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-% %ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-% %ctrl.v=@(t,q,p) zeros(6,1);\r\n-% %input u from eq.(20)\r\n-% ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p));\r\n-\r\n-% % Define  closed-loop energy in eq.(24)\r\n-% ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-% ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-% ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-%Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15) \r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n-%K=tril(ones(6));\r\n-beta = 100000;\r\n-gamma = 3;\r\n-delta = 1;\r\n-alpha =  diag([100000;100000;100000;100000;100000;100000]);\r\n-eposlion=10;\r\n-% ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n-ctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n- %phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym,t_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-he=sym(0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-%he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n-%\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-ctrl.v=@(t,q,p) (-inv(dphidep(p,t))*Lambda(q,p,t)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p,t))*dphideq(q,t))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-%ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-%ctrl.v=@(t,q,p) zeros(6,1);\r\n-%input u from eq.(20)\r\n-ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p));\r\n-\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729840228807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,15 +48,15 @@\n   Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n \r\n he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{p_sym}]);\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n %Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n  % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1729840539196,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n+ K2=diag([500;500;500;500;500;300]);\r\n+beta = 100000;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) K*ctrl.eq(t,q) + alpha*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   K3 = diag([5;5;5;5;5;5]);\r\n+    % K3 = diag([0;0;0;0;0;0]);\r\n+  Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n+\r\n+he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+ % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729840578753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,13 +30,13 @@\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n  alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n- K2=diag([500;500;500;500;500;300]);\r\n+ K=diag([500;500;500;500;500;300]);\r\n beta = 100000;\r\n gamma = 3;\r\n delta = 1;\r\n-ctrl.phi=@(t,q,p) K*ctrl.eq(t,q) + alpha*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n %Take a partial derivative of \\phi\r\n dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n"
                },
                {
                    "date": 1729842625284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n  alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n  K=diag([500;500;500;500;500;300]);\r\n-beta = 100000;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n@@ -64,71 +64,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- K=diag([500000;500000;500000;500000;500000;500000]);\r\n- K2=diag([500;500;500;500;500;300]);\r\n-beta = 100000;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) K*ctrl.eq(t,q)+K2*ctrl.ep(t,q,p)+ beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   K3 = diag([5;5;5;5;5;5]);\r\n-    % K3 = diag([0;0;0;0;0;0]);\r\n-  Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n-\r\n-he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n- % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729842691242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,66 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n+beta =diag([500000;500000;500000;500000;500000;500000]);\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   K3 = diag([5;5;5;5;5;5]);\r\n+    % K3 = diag([0;0;0;0;0;0]);\r\n+  Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n+\r\n+he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+ % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729842914566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,76 +30,10 @@\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n  alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n-beta =diag([500000;500000;500000;500000;500000;500000]);\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   K3 = diag([5;5;5;5;5;5]);\r\n-    % K3 = diag([0;0;0;0;0;0]);\r\n-  Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n-\r\n-he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n- % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n  K=diag([500;500;500;500;500;300]);\r\n- alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n+beta = diag([500000;500000;500000;500000;500000;500000]);\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1729843003706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n  alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n  K=diag([500;500;500;500;500;300]);\r\n-beta = diag([500000;500000;500000;500000;500000;500000]);\r\n+beta = 10000;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1731722045825,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,10 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n- K=diag([500;500;500;500;500;300]);\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n@@ -42,25 +42,25 @@\n dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n-   K3 = diag([5;5;5;5;5;5]);\r\n-    % K3 = diag([0;0;0;0;0;0]);\r\n-  Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n-\r\n+     K3 = diag([5;5;5;5;5;5]);\r\n+     % K3 = diag([0;0;0;0;0;0]);\r\n+    ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+ % ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n %Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n- % ctrl.v=@(t,q,p) 0;\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n"
                },
                {
                    "date": 1731722197457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,10 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.01;\r\n beta = 10000;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n"
                },
                {
                    "date": 1731722242729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,10 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.01;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n+ K=diag([500;500;500;500;500;300]);\r\n beta = 10000;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n"
                },
                {
                    "date": 1731722292890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.5;\r\n  K=diag([500;500;500;500;500;300]);\r\n beta = 10000;\r\n gamma = 3;\r\n delta = 1;\r\n"
                },
                {
                    "date": 1731722302065,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.5;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n  K=diag([500;500;500;500;500;300]);\r\n beta = 10000;\r\n gamma = 3;\r\n delta = 1;\r\n"
                },
                {
                    "date": 1731722341367,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,10 +30,10 @@\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n  alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300]);\r\n-beta = 10000;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1731722484241,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([50000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+     K3 = diag([5;5;5;5;5;5]);\r\n+     % K3 = diag([0;0;0;0;0;0]);\r\n+    ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+ % ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732425729830,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,75 +29,8 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([50000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-     K3 = diag([5;5;5;5;5;5]);\r\n-     % K3 = diag([0;0;0;0;0;0]);\r\n-    ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n- % ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n  alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.1;\r\n gamma = 3;\r\n"
                },
                {
                    "date": 1732425772527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+      K3 = diag([0;0;0;0;0;0]);\r\n+    ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+ % ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732426296725,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,10 +43,10 @@\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n    %   K3 = diag([5;5;5;5;5;5]);\r\n-      K3 = diag([0;0;0;0;0;0]);\r\n-    ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+   %    K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n  % ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n@@ -64,71 +64,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-     K3 = diag([5;5;5;5;5;5]);\r\n-     % K3 = diag([0;0;0;0;0;0]);\r\n-    ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n- % ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732455255288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732504261718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ alpha=diag([5000000;500000;500000;500000;500000;500000])*0.1;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.1;\r\n gamma = 3;\r\n delta = 1;\r\n@@ -64,71 +64,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-   %    K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n- % ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732520770034,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([5000000;500000;500000;500000;500000;500000])*0.1;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.1;\r\n gamma = 3;\r\n delta = 1;\r\n"
                },
                {
                    "date": 1732713934139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732714034831,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732714326952,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,11 +29,11 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.5;\r\n+ K=diag([500;500;500;500;500;300])*0.5;\r\n+beta = 10000*0.5;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n@@ -64,138 +64,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732770796723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,11 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+mu= 0.5;\r\n+dUdPhi = matlabFunction((2-mu)*abs(ctrl.phi(t_sym,q_sym,p_sym))^(1-mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu)*abs(ctrl.phi(t_sym,q_sym,p_sym))^(1+mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)));\r\n+%dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n"
                },
                {
                    "date": 1732770819945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,69 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.5;\r\n+ K=diag([500;500;500;500;500;300])*0.5;\r\n+beta = 10000*0.5;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.5;\r\n+dUdPhi = matlabFunction((2-mu)*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu)*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)));\r\n+%dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732770841640,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu)*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu)*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)));\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)));\r\n %dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n@@ -66,73 +66,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.5;\r\n- K=diag([500;500;500;500;500;300])*0.5;\r\n-beta = 10000*0.5;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu)*abs(ctrl.phi(t_sym,q_sym,p_sym))^(1-mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu)*abs(ctrl.phi(t_sym,q_sym,p_sym))^(1+mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)));\r\n-%dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732770928762,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)));\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n %dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732771029186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,11 +29,11 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.5;\r\n- K=diag([500;500;500;500;500;300])*0.5;\r\n-beta = 10000*0.5;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.2;\r\n+ K=diag([500;500;500;500;500;300])*0.2;\r\n+beta = 10000*0.2;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1732771073119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,11 +29,11 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.2;\r\n- K=diag([500;500;500;500;500;300])*0.2;\r\n-beta = 10000*0.2;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1732771178630,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,11 +29,11 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n+beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1732771480864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,10 +53,10 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))+(1+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))+(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n"
                },
                {
                    "date": 1732771766951,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))+(1+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))+(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732771781258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732772287005,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+(2+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732772336083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.5;\r\n+mu= 0.3;\r\n dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+(2+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732772478829,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.3;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+(2+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732772497556,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.3;\r\n-dUdPhi = matlabFunction((2+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732773591857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,14 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.3;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+p_i = 0.5;\r\n+m_i = 0.5;\r\n+k4 = diag([2;2;2;2;2;2]);\r\n+k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n@@ -64,6 +69,6 @@\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.U=matlabFunction(abs()+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732773658997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,6 +69,6 @@\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(abs()+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.U=matlabFunction(abs(normPhi).^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732773676550,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,6 +69,6 @@\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(abs(normPhi).^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.U=matlabFunction(abs(normPhi).^(2-mu)+k4*(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732774235587,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,6 +69,6 @@\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(abs(normPhi).^(2-mu)+k4*(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+k4*(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732774621160,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,6 +69,6 @@\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+k4*(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732774835802,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n mu= 0.3;\r\n p_i = 0.5;\r\n m_i = 0.5;\r\n k4 = diag([2;2;2;2;2;2]);\r\n-k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym))\r\n \r\n dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n"
                },
                {
                    "date": 1732779061061,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n \r\n dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732799406348,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n m_i = 0.5;\r\n k4 = diag([2;2;2;2;2;2]);\r\n k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym))\r\n \r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732799431653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.3;\r\n+p_i = 0.5;\r\n+m_i = 0.5;\r\n+k4 = diag([2;2;2;2;2;2]);\r\n+k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732799714654,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n m_i = 0.5;\r\n k4 = diag([2;2;2;2;2;2]);\r\n k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n@@ -71,78 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.3;\r\n-p_i = 0.5;\r\n-m_i = 0.5;\r\n-k4 = diag([2;2;2;2;2;2]);\r\n-k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym))\r\n-\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732844617089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.3;\r\n+p_i = 0.5;\r\n+m_i = 0.5;\r\n+k4 = diag([2;2;2;2;2;2]);\r\n+k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732844622941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,12 +53,12 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.3;\r\n-p_i = 0.5;\r\n-m_i = 0.5;\r\n-k4 = diag([2;2;2;2;2;2]);\r\n-k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+% k4 = diag([2;2;2;2;2;2]);\r\n+% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n@@ -71,78 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.3;\r\n-p_i = 0.5;\r\n-m_i = 0.5;\r\n-k4 = diag([2;2;2;2;2;2]);\r\n-k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n-\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732848561739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,11 @@\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n+  + abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n++2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732848670492,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.3;\r\n+mu= 0.2;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n"
                },
                {
                    "date": 1732848703322,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.2;\r\n+mu= 0.5;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n"
                },
                {
                    "date": 1732848859848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.5;\r\n+mu= 0.4;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n"
                },
                {
                    "date": 1732848882116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.4;\r\n+mu= 0.1;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n"
                },
                {
                    "date": 1732848988263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,10 +59,9 @@\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-  + abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-+2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+                        +2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732869877305,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n % passed in via sys and ctrl\r\n % input: sys, ctrl\r\n % output: ctrl\r\n function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n q_sym = [q1 q2 q3 q4 q5 q6].';\r\n p_sym = [p1 p2 p3 p4 p5 p6].';\r\n \r\n ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n@@ -59,12 +59,12 @@\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+                        +((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732869921461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,9 +62,9 @@\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n                         +((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732871301857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.1;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+% k4 = diag([2;2;2;2;2;2]);\r\n+% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n+                        +k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732871334286,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+                        +k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[k4,{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n@@ -72,79 +72,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.1;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-% k4 = diag([2;2;2;2;2;2]);\r\n-% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732871354572,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[k4,{t_sym},{q_sym},{p_sym}]);\r\n+                        +k4.*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[k4,{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732871473396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +k4.*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[k4,{t_sym},{q_sym},{p_sym}]);\r\n+                        +k4.*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732871519594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +k4.*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+                        +k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732872155290,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,10 +58,9 @@\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732955132833,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,15 +52,15 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.1;\r\n+mu= 0.6;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction(k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732955152534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+% k4 = diag([2;2;2;2;2;2]);\r\n+% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733051258220,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.01;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n@@ -71,78 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-% k4 = diag([2;2;2;2;2;2]);\r\n-% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733051303542,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.01;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n"
                },
                {
                    "date": 1733051517595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+1*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733052113160,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+1*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+10*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733052192320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+10*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+5*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733052462769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+5*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+1*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733053192037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+1*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733108722119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,12 +42,12 @@\n dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n+      K3 = diag([5;5;5;5;5;5]);\r\n+      %  K3 = diag([0;0;0;0;0;0]);\r\n+     ctrl.Kd =@(t,q) K3 + ((tanh(2*ctrl.eq(t,q).^2-2)).^2+1).*K3;\r\n+%   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n"
                },
                {
                    "date": 1733109265155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n-      K3 = diag([5;5;5;5;5;5]);\r\n+      K3 = [5;5;5;5;5;5];\r\n       %  K3 = diag([0;0;0;0;0;0]);\r\n      ctrl.Kd =@(t,q) K3 + ((tanh(2*ctrl.eq(t,q).^2-2)).^2+1).*K3;\r\n %   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n@@ -65,9 +65,9 @@\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n- ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+ ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n"
                },
                {
                    "date": 1733110457453,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n       %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + ((tanh(2*ctrl.eq(t,q).^2-2)).^2+1).*K3;\r\n+     ctrl.Kd =@(t,q) K3 + ((tanh(20*ctrl.eq(t,q).^2-2)).^2+1).*K3;\r\n %   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733111015798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+      %  K3 = diag([0;0;0;0;0;0]);\r\n+     ctrl.Kd =@(t,q) K3 + ((tanh(20*ctrl.eq(t,q).^2-2.5)).^2).*K3;\r\n+%   ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+% k4 = diag([2;2;2;2;2;2]);\r\n+% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733111086500,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n       %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + ((tanh(20*ctrl.eq(t,q).^2-2.5)).^2).*K3;\r\n+     ctrl.Kd =@(t,q) K3 + ((tanh(1.420*ctrl.eq(t,q).^2-2.5)).^2).*K3;\r\n %   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n@@ -71,78 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-      %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + ((tanh(20*ctrl.eq(t,q).^2-2)).^2+1).*K3;\r\n-%   ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-% k4 = diag([2;2;2;2;2;2]);\r\n-% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733122083699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+      %  K3 = diag([0;0;0;0;0;0]);\r\n+     ctrl.Kd =@(t,q) K3 + ((tanh(1.4*20*ctrl.eq(t,q).^2-2.5)).^2).*K3;\r\n+%   ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+% k4 = diag([2;2;2;2;2;2]);\r\n+% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733122313729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n       %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + ((tanh(1.4*20*ctrl.eq(t,q).^2-2.5)).^2).*K3;\r\n+     ctrl.Kd =@(t,q) K3 + ((tanh(1.4*5*ctrl.eq(t,q).^2-2.5)).^2).*K3;\r\n %   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n@@ -71,78 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-      %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + ((tanh(1.420*ctrl.eq(t,q).^2-2.5)).^2).*K3;\r\n-%   ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-% k4 = diag([2;2;2;2;2;2]);\r\n-% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733122597607,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n       %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + ((tanh(1.4*5*ctrl.eq(t,q).^2-2.5)).^2).*K3;\r\n+     ctrl.Kd =@(t,q) K3 + ((tanh(1.4*(5*ctrl.eq(t,q)).^2-2.5)).^2).*K3;\r\n %   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733122671779,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n       %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + ((tanh(1.4*(5*ctrl.eq(t,q)).^2-2.5)).^2).*K3;\r\n+     ctrl.Kd =@(t,q) K3 + ((tanh(1.4*(20*ctrl.eq(t,q)).^2-2.5)).^2).*K3;\r\n %   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733122819112,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n       %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + ((tanh(1.4*(20*ctrl.eq(t,q)).^2-2.5)).^2).*K3;\r\n+     ctrl.Kd =@(t,q) K3 + ((tanh(1.4*(ctrl.eq(t,q)/20).^2-2.5)).^2).*K3;\r\n %   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733123844940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+      %  K3 = diag([0;0;0;0;0;0]);\r\n+     ctrl.Kd =@(t,q) K3 + ((tanh(0.9*(ln(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n+%   ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+% k4 = diag([2;2;2;2;2;2]);\r\n+% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733124030925,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n       %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + ((tanh(0.9*(ln(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n+     ctrl.Kd =@(t,q) K3 + (tanh(0.9*(ln(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n %   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n@@ -71,78 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-      %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + ((tanh(1.4*(ctrl.eq(t,q)/20).^2-2.5)).^2).*K3;\r\n-%   ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-% k4 = diag([2;2;2;2;2;2]);\r\n-% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733124046382,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n       %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + (tanh(0.9*(ln(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n+     ctrl.Kd =@(t,q) K3 + (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n %   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733124235528,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n       %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n+     ctrl.Kd =@(t,q)  (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n %   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733124303171,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n       %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q)  (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n+     ctrl.Kd =@(t,q) K3 + (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n %   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733124377066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n"
                },
                {
                    "date": 1733124415141,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n+      K3 = [5;5;5;10;10;5];\r\n       %  K3 = diag([0;0;0;0;0;0]);\r\n      ctrl.Kd =@(t,q) K3 + (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n %   ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n"
                },
                {
                    "date": 1733124638557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,11 +43,11 @@\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;10;10;5];\r\n-      %  K3 = diag([0;0;0;0;0;0]);\r\n-     ctrl.Kd =@(t,q) K3 + (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n-%   ctrl.Kd = @(t,q) K3;\r\n+\r\n+   %   ctrl.Kd =@(t,q) K3 + (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n+   ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n"
                },
                {
                    "date": 1733124779667,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,12 +42,12 @@\n dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;10;10;5];\r\n+      K3 = 2*[5;5;5;10;10;5];\r\n \r\n-   %   ctrl.Kd =@(t,q) K3 + (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n-   ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n"
                },
                {
                    "date": 1733124899237,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n-      K3 = 2*[5;5;5;10;10;5];\r\n+      K3 = 10*[5;5;5;10;10;5];\r\n \r\n       ctrl.Kd =@(t,q) K3 + (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n"
                },
                {
                    "date": 1733125130491,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n-      K3 = 10*[5;5;5;10;10;5];\r\n+      K3 = [5;5;5;10;10;5];\r\n \r\n       ctrl.Kd =@(t,q) K3 + (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n"
                },
                {
                    "date": 1733141804543,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n"
                },
                {
                    "date": 1733143684463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;10;10;5];\r\n \r\n-      ctrl.Kd =@(t,q) K3 + (tanh(0.9*(log(1+abs(ctrl.eq(t,q))).^2-2.7)).^2).*K3;\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2.3*(log(1+abs(ctrl.eq(t,q)))-2.5)).^2).*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733143893534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;10;10;5];\r\n \r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2.3*(log(1+abs(ctrl.eq(t,q)))-2.5)).^2).*K3;\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2.3*log(1+abs(ctrl.eq(t,q))-3.9)).^2).*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733143955516,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;10;10;5];\r\n \r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2.3*log(1+abs(ctrl.eq(t,q))-3.9)).^2).*K3;\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2.3*log(1+abs(ctrl.eq(t,q))-2.5)).^2).*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733143963560,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;10;10;5];\r\n \r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2.3*log(1+abs(ctrl.eq(t,q))-2.5)).^2).*K3;\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2.3*log(1+abs(ctrl.eq(t,q))^2-2.5)).^2).*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733143975819,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;10;10;5];\r\n \r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2.3*log(1+abs(ctrl.eq(t,q))^2-2.5)).^2).*K3;\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2.3*log(1+abs(ctrl.eq(t,q)).^2-2.5)).^2).*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733144328863,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;10;10;5];\r\n \r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2.3*log(1+abs(ctrl.eq(t,q)).^2-2.5)).^2).*K3;\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q)).^2-2.5)).^2).*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733144565059,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;10;10;5];\r\n \r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q)).^2-2.5)).^2).*K3;\r\n+      ctrl.Kd =@(t,q)  (tanh(2*log(1+abs(ctrl.eq(t,q)).^2-2.5)).^2).*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733145130337,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;10;10;5];\r\n \r\n-      ctrl.Kd =@(t,q)  (tanh(2*log(1+abs(ctrl.eq(t,q)).^2-2.5)).^2).*K3;\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q)).^2-2.5)).^2).*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733145232516,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;10;10;5];\r\n+\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-2.5)).^2).*K3;\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+% k4 = diag([2;2;2;2;2;2]);\r\n+% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733145254616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;10;10;5];\r\n \r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-2.5)).^2).*K3;\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-2.5)).^2.*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n@@ -71,78 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;10;10;5];\r\n-\r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q)).^2-2.5)).^2).*K3;\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-% k4 = diag([2;2;2;2;2;2]);\r\n-% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733146431445,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-2.5)).^2.*K3;\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+% k4 = diag([2;2;2;2;2;2]);\r\n+% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733146488507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ alpha=diag([500000;500000;500000;200000;200000;200000])*0.1;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n@@ -71,78 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;10;10;5];\r\n-\r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-2.5)).^2.*K3;\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-% k4 = diag([2;2;2;2;2;2]);\r\n-% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733146602834,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;200000;200000;200000])*0.1;\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.1;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n"
                },
                {
                    "date": 1733451197069,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-2.5)).^2.*K3;\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+% k4 = diag([2;2;2;2;2;2]);\r\n+% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+%  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+ ctrl.u=@(t,q,p) ctrl.G(q)\\(-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733451351124,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,83 +66,9 @@\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n %  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n- ctrl.u=@(t,q,p) ctrl.G(q)\\(-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+ ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-2.5)).^2.*K3;\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-% k4 = diag([2;2;2;2;2;2]);\r\n-% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733451654898,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,9 +66,9 @@\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n %  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n- ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+ ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733539152246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n \r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-2.5)).^2.*K3;\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n@@ -55,11 +55,10 @@\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.6;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n-% k4 = diag([2;2;2;2;2;2]);\r\n-% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n+\r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733539211418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,73 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733573917956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,73 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+ctrl.u= @(k4,t,q,p) (-10.*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733573928982,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,156 +64,10 @@\n    % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n ctrl.u= @(k4,t,q,p) (-10.*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n %  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n-%  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n- ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733573947334,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-ctrl.u= @(k4,t,q,p) (-10.*ctrl.ep(t,q,p));\r\n+ctrl.v= @(k4,t,q,p) (-10.*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n %  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733574647151,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-ctrl.v= @(k4,t,q,p) (-10.*ctrl.ep(t,q,p));\r\n+ctrl.v= @(k4,t,q,p) (-10000.*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n %  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733574799698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-ctrl.v= @(k4,t,q,p) (-10000.*ctrl.ep(t,q,p));\r\n+ctrl.v= @(k4,t,q,p) (-1000000.*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n %  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733575147867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-ctrl.v= @(k4,t,q,p) (-1000000.*ctrl.ep(t,q,p));\r\n+ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n %  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733575450187,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,10 +60,10 @@\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-   % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n %  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733575597033,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,11 +60,11 @@\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n+    ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n %  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n % Define  closed-loop energy in eq.(24)\r\n"
                },
                {
                    "date": 1733575617954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,9 +62,9 @@\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-    ctrl.v=@(t,q,p) 0;\r\n+    ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n %  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n % Define  closed-loop energy in eq.(24)\r\n"
                },
                {
                    "date": 1733575928182,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,9 +64,9 @@\n    %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n     ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n %  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n"
                },
                {
                    "date": 1733577408626,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,11 +60,11 @@\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-   %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+     ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-    ctrl.v=@(k4,t,q,p) 0;\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n %  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n % Define  closed-loop energy in eq.(24)\r\n"
                },
                {
                    "date": 1733577488035,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,10 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n \r\n-      ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+      % ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+      ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733577499154,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.06;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+      % ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+      ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+     ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733577538170,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.06;\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.05;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n@@ -71,78 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-      % ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n-      ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-     ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733577583444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+      % ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+      ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+     ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733577720445,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,10 +44,10 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n \r\n-      % ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n-      ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+       ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+      % ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n@@ -71,78 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.05;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-      % ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n-      ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-     ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733577786483,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,9 +44,9 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n \r\n-       ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+       ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-2.5)).^2.*K3;\r\n       % ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n"
                },
                {
                    "date": 1733577963803,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,10 +44,10 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n \r\n-       ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-2.5)).^2.*K3;\r\n-      % ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+      %  ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-2.5)).^2.*K3;\r\n+       ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733578135316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,10 +44,10 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n \r\n-      %  ctrl.Kd =@(t,q) K3 + (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-2.5)).^2.*K3;\r\n-       ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+        ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %  ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733578320674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,10 +44,10 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n \r\n-        ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %  ctrl.Kd =@(t,q) K3 - (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+        ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733579051174,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,10 +44,10 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n \r\n-      %   ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-        ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1733626661789,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   %   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733626671531,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733627317776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733627401242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733628452914,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n@@ -71,300 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   %   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-     ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733628461350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n \r\n          ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n       %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n"
                },
                {
                    "date": 1733628488721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733629168753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,9 +47,9 @@\n \r\n          ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n       %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n@@ -61,9 +61,9 @@\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733641742976,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733833373574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733834323197,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+% he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+      % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733834339472,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+% he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+      % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733834806315,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,10 +47,10 @@\n \r\n          ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n       %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-% he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+ he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+% he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n@@ -61,10 +61,10 @@\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-      % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+       ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+      % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n"
                },
                {
                    "date": 1733836128323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+%  he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+ he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+      %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+       ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733836617424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+  he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+%  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+       ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+      %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733837023285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,10 +47,10 @@\n \r\n          ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n       %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-  he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-%  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+%   he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n@@ -61,85 +61,10 @@\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-       ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-      %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-%  he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n- he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n       %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-       ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+        ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n@@ -147,450 +72,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n- he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-% he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-       ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-      % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-% he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-      % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q).*ctrl.ep(t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733837955652,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733838194256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,10 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;400000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n+ alpha=diag([500000;500000;500000;400000;400000;0])*0.01;\r\n+ K=diag([500;500;500;500;500;0])*0.1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n"
                },
                {
                    "date": 1733838213561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,10 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;0])*0.01;\r\n- K=diag([500;500;500;500;500;0])*0.1;\r\n+ alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n+ K=diag([500;500;500;500;500;1])*0.1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n"
                },
                {
                    "date": 1733838831182,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n+ K=diag([500;500;500;500;500;1])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+   he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+%   he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+       ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+      %   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733840195912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n+mu= 0.5;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n@@ -72,79 +72,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n- K=diag([500;500;500;500;500;1])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-%   he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.6;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-      %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-        ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733840689807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n+ K=diag([500;500;500;500;500;1])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+   % he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+   he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.5;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+      %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733840864987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(2*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n          ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1733841004605,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,10 +47,10 @@\n \r\n          ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n       %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-   % he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-   he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+   % he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n@@ -61,10 +61,10 @@\n \r\n dUdPhi = matlabFunction(2*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-      %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+        ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+         % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n"
                },
                {
                    "date": 1733841024813,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n+ K=diag([500;500;500;500;500;1])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+   % he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.7;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(2*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+        ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+         % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733841030025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(2*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n          % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n@@ -72,154 +72,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n- K=diag([500;500;500;500;500;1])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-   % he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.5;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(2*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-        ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-         % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n- K=diag([500;500;500;500;500;1])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-   he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-%   he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.5;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-       ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-      %   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733841219434,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,24 +47,24 @@\n \r\n          ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n       %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-   % he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+   %  he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+    he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.7;\r\n+mu= 0.4;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-        ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-         % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+      %   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+          ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n"
                },
                {
                    "date": 1733841640721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.4;\r\n+mu= 0.2;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n"
                },
                {
                    "date": 1733842212245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,10 +47,10 @@\n \r\n          ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n       %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-   %  he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-    he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+   %  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n@@ -61,10 +61,10 @@\n \r\n dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-      %   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-          ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n"
                },
                {
                    "date": 1733842217437,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n+ K=diag([500;500;500;500;500;1])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+   %  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.4;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733879833070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n+ alpha=diag([500000;500000;500000;400000;400000;1])*0.005;\r\n  K=diag([500;500;500;500;500;1])*0.1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n@@ -72,79 +72,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n- K=diag([500;500;500;500;500;1])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-   %  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.2;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733880108913,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;1])*0.005;\r\n+ K=diag([500;500;500;500;500;1])*0.01;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+   %  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.4;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733887250541,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,84 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;1])*0.005;\r\n- K=diag([500;500;500;500;500;1])*0.01;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-   %  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.4;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;1])*0.005;\r\n+ alpha=diag([500000;500000;500000;400000;400000;1])*0.05;\r\n  K=diag([500;500;500;500;500;1])*0.1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n"
                },
                {
                    "date": 1733887261666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;1])*0.05;\r\n+ K=diag([500;500;500;500;500;1])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         % ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+         ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+   %  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.4;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733887395482,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n+ K=diag([500;500;500;500;500;1])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+         % ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+         ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+   %  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.4;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733970347862,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n+ K=diag([500;500;500;500;500;1])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+          ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+         % ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+   %  he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+     he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.4;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+         % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+          ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733970756010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n          % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n           ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n@@ -72,229 +72,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n- K=diag([500;500;500;500;500;1])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         % ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-         ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-   %  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.4;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;1])*0.05;\r\n- K=diag([500;500;500;500;500;1])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         % ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-         ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-   %  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.4;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;1])*0.05;\r\n- K=diag([500;500;500;500;500;1])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-         ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-      %   ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-   %  he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.4;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-         ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1733971128258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,10 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;1])*0.01;\r\n- K=diag([500;500;500;500;500;1])*0.1;\r\n+ alpha=diag([500000;500000;500000;400000;400000;1])*0.1;\r\n+ K=diag([500;500;500;500;500;1])*1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n"
                },
                {
                    "date": 1733971320334,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;400000;400000;1])*0.1;\r\n+ alpha=diag([500000;500000;500000;500000;500000;1])*0.1;\r\n  K=diag([500;500;500;500;500;1])*1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n"
                },
                {
                    "date": 1733971608745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,10 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;1])*0.1;\r\n- K=diag([500;500;500;500;500;1])*1;\r\n+ alpha=diag([500000;500000;500000;500000;500000;1])*0.01;\r\n+ K=diag([500;500;500;500;500;1])*0.1;\r\n beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n"
                },
                {
                    "date": 1733971621593,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,10 +47,10 @@\n \r\n           ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n          % ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-   %  he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-     he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+   %   he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n@@ -61,10 +61,10 @@\n \r\n dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-         % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-          ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+          ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n"
                },
                {
                    "date": 1733988192763,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,10 +44,10 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n \r\n-          ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-         % ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+         %  ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+          ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n     he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n    %   he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n@@ -61,10 +61,10 @@\n \r\n dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-          ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+          ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n"
                },
                {
                    "date": 1734743990574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,29 +47,29 @@\n \r\n          %  ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n           ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-    he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-   %   he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+    % he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+      he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.4;\r\n+mu= 0.2;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)+0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-         %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-          ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+          ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+          % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n-  ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-%  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(10.*ctrl.ep(t,q,p));\r\n+  % ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(-10.*ctrl.ep(t,q,p));\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1734744186156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,13 +63,13 @@\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n           ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n           % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+ ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n-  % ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-  ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(-10.*ctrl.ep(t,q,p));\r\n+   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+  % ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(-10.*ctrl.ep(t,q,p));\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1734745723280,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,6 +70,7 @@\n    ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n   % ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(-10.*ctrl.ep(t,q,p));\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+% ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.U = @(t,q,p)  0;\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1734746784580,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,9 +63,9 @@\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n           ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n           % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n- ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+%  ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n    ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n   % ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(-10.*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1734747056160,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,18 +53,18 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.2;\r\n+mu= 0.5;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)+0*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)+1*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-          ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-          % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+          % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+           ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %  ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n    ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n"
                },
                {
                    "date": 1734747332797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)+1*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+1*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n           % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n            ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1734747444463,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+1*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+1*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n           % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n            ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1734747812877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,13 +58,13 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+1*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-          % ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-           ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+           ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+          %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %  ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n    %  ctrl.v=@(k4,t,q,p) 0;\r\n %input u from eq.(20)\r\n    ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n"
                },
                {
                    "date": 1734748001998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,10 +44,10 @@\n \r\n %compute the Lambda from eq.(22)\r\n       K3 = [5;5;5;5;5;5];\r\n \r\n-         %  ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-          ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+           ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+          % ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n    % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n     % he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n       he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n"
                },
                {
                    "date": 1734748096850,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,11 +29,11 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;1])*0.01;\r\n- K=diag([500;500;500;500;500;1])*0.1;\r\n-beta = 10000*0.05;\r\n+ alpha=diag([500000;500000;500000;500000;500000;1])*0.05;\r\n+ K=diag([500;500;500;500;500;1])*0.5;\r\n+beta = 10000*0.1;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1734917348660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n            ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n           %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1734917664350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.5*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n            ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n           %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1734917681154,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.5*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.1*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n            ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n           %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1734917692849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.1*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n            ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n           %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1734917711388,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.01*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n            ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n           %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1734917806353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.01*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.001*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n            ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n           %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1734918563849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,76 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;1])*0.05;\r\n+ K=diag([500;500;500;500;500;1])*0.5;\r\n+beta = 10000*0.1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+      K3 = [5;5;5;5;5;5];\r\n+\r\n+           ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n+          % ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n+   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n+    % he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+      he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.5;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+\r\n+\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.00*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+           ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n+          %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%  ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n+   %  ctrl.v=@(k4,t,q,p) 0;\r\n+%input u from eq.(20)\r\n+   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n+  % ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(-10.*ctrl.ep(t,q,p));\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+% ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.U = @(t,q,p)  0;\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1734919064965,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.00*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.1*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n            ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n           %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n@@ -73,80 +73,4 @@\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n % ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.U = @(t,q,p)  0;\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;1])*0.05;\r\n- K=diag([500;500;500;500;500;1])*0.5;\r\n-beta = 10000*0.1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-      K3 = [5;5;5;5;5;5];\r\n-\r\n-           ctrl.Kd =@(t,q) K3 + (tanh(5*log(1+abs(ctrl.eq(t,q))).^2-1)).^2.*K3;\r\n-          % ctrl.Kd =@(t,q) K3.*(2- (tanh(2*log(1+abs(ctrl.eq(t,q))).^2-0)).^2);\r\n-   % ctrl.Kd = @(t,q) [0;0;0;0;0;0];\r\n-    % he=sym(0.5*(dphideq(t_sym,q_sym)*((diag(ctrl.Kd(t_sym,q_sym))+ctrl.D(q_sym))))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-      he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.5;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-\r\n-\r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.001*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-           ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n-          %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%  ctrl.v= @(k4,t,q,p) (-100000.*ctrl.ep(t,q,p));\r\n-   %  ctrl.v=@(k4,t,q,p) 0;\r\n-%input u from eq.(20)\r\n-   ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p));\r\n-  % ctrl.u= @(k4,t,q,p) ctrl.G(q)\\(-10.*ctrl.ep(t,q,p));\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-% ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.U = @(t,q,p)  0;\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1734919123506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.5;\r\n+mu= 0.8;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n"
                },
                {
                    "date": 1734919915312,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,10 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;1])*0.05;\r\n- K=diag([500;500;500;500;500;1])*0.5;\r\n+ alpha=diag([500000;500000;500000;500000;500000;1])*0.01;\r\n+ K=diag([500;500;500;500;500;1])*0.1;\r\n beta = 10000*0.1;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n"
                },
                {
                    "date": 1734920274015,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n \r\n \r\n-dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.1*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(4*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+0.0*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n            ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(diag(ctrl.Kd(t,q))+ctrl.D(q)))*ctrl.ep(t,q,p));\r\n           %  ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                }
            ],
            "date": 1729819406605,
            "name": "Commit-0",
            "content": "%% This script defines the TSMC controller, and its generated energy function.\r\n% input: sys, ctrl\r\n% output: ctrl\r\nfunction [ctrl]=TSMCController(sys,ctrl)\r\nsyms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\nq_sym = [q1 q2 q3 q4 q5 q6].';\r\np_sym = [p1 p2 p3 p4 p5 p6].';\r\n\r\nctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n\r\nctrl.p = @(q,p) ctrl.T(q)'*p;\r\nctrl.D = @(q) sys.D(q);\r\nctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n\r\n% Compute the target momentum from (13)\r\n%期望动量的坐标变换\r\nctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n\r\n% Compute the error coordinates on q, p from (11), (15) \r\n%速度和动量误差\r\nctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\nctrl.eq = @(t,q) q - ctrl.qd(t);\r\n% Compute the gradient of the reference momentum with respect to\r\n% configuration as per (16)\r\n%求期望动量的梯度\r\nctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n%% Define Passivity-based sliding mode controller\r\n%VI. NUMERICAL EXAMPLE Case1 and K\r\n%K=tril(ones(6));\r\nbeta = 1;\r\ngamma = 3;\r\ndelta = 1;\r\nalpha =  diag([500;500;500;500;500;500]);\r\neposlion=10;\r\n% ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\nctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n %phi=@(q,p) K*q+tan(p);\r\n%Take a partial derivative of \\phi\r\ndphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym,t_sym});\r\ndphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n%Replace the variable to be determined q with eq(\\tilde \\q)\r\n\r\n%compute the Lambda from eq.(22)\r\nhe=sym(500*0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n%he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\nLambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n%\r\n%Compute the partial derivative of U\r\nnormPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\ndUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n%Then the feedback controller from eq.(23)\r\nctrl.v=@(t,q,p) (-inv(dphidep(p,t))*Lambda(q,p,t)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p,t))*dphideq(q,t))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n%ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n%ctrl.v=@(t,q,p) zeros(6,1);\r\n%input u from eq.(20)\r\nctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p));\r\n\r\n% Define  closed-loop energy in eq.(24)\r\nctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\nctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\nctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
        }
    ]
}