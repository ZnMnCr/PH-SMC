{
    "sourceFile": "simulation_scripts/TSMCController.m",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 71,
            "patches": [
                {
                    "date": 1729819406605,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1729819563406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+%Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15) \r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+%K=tril(ones(6));\r\n+beta = 1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+alpha =  diag([500;500;500;500;500;500]);\r\n+eposlion=10;\r\n+% ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n+ctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n+ %phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym,t_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+he=sym(500*0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+%he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n+%\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+ctrl.v=@(t,q,p) (-inv(dphidep(p,t))*Lambda(q,p,t)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p,t))*dphideq(q,t))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+%ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+%ctrl.v=@(t,q,p) zeros(6,1);\r\n+%input u from eq.(20)\r\n+ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p));\r\n+\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729820272035,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n %K=tril(ones(6));\r\n beta = 1;\r\n gamma = 3;\r\n delta = 1;\r\n-alpha =  diag([500;500;500;500;500;500]);\r\n+alpha =  diag([50000;50000;50000;50000;50000;50000]);\r\n eposlion=10;\r\n % ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n ctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n  %phi=@(q,p) K*q+tan(p);\r\n@@ -43,9 +43,9 @@\n dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n-he=sym(500*0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+he=sym(0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n %he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\n Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n %\r\n %Compute the partial derivative of U\r\n@@ -61,65 +61,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15) \r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n-%K=tril(ones(6));\r\n-beta = 1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-alpha =  diag([500;500;500;500;500;500]);\r\n-eposlion=10;\r\n-% ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n-ctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n- %phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym,t_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-he=sym(500*0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-%he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n-%\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-ctrl.v=@(t,q,p) (-inv(dphidep(p,t))*Lambda(q,p,t)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p,t))*dphideq(q,t))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-%ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-%ctrl.v=@(t,q,p) zeros(6,1);\r\n-%input u from eq.(20)\r\n-ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p));\r\n-\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729820354811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,12 +29,12 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n %K=tril(ones(6));\r\n-beta = 1;\r\n+beta = 500000;\r\n gamma = 3;\r\n delta = 1;\r\n-alpha =  diag([50000;50000;50000;50000;50000;50000]);\r\n+alpha =  diag([500000;500000;500000;500000;500000;500000]);\r\n eposlion=10;\r\n % ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n ctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n  %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1729820547869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,12 +29,12 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n %K=tril(ones(6));\r\n-beta = 500000;\r\n+beta = 100000;\r\n gamma = 3;\r\n delta = 1;\r\n-alpha =  diag([500000;500000;500000;500000;500000;500000]);\r\n+alpha =  diag([100000;100000;100000;100000;100000;100000]);\r\n eposlion=10;\r\n % ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n ctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n  %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1729838658903,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,96 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15) \r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+%K=tril(ones(6));\r\n+beta = 10000;\r\n+gamma = 3;\r\n+delta = 1;\r\n+alpha =  diag([50000;50000;50000;50000;50000;50000]);\r\n+ K2=diag([500;500;500;500;500;300]);\r\n+eposlion=10;\r\n+% ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n+ctrl.phi = @(t,q,p) K2*ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n+ %phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq=matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep=matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   K3 = diag([5;5;5;5;5;5]);\r\n+    % K3 = diag([0;0;0;0;0;0]);\r\n+  Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n+\r\n+he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+ % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n+\r\n+\r\n+\r\n+\r\n+% dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym,t_sym});\r\n+% dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n+% %Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+% %compute the Lambda from eq.(22)\r\n+% he=sym(0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+% %he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\n+% Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n+% %\r\n+% %Compute the partial derivative of U\r\n+% normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+% %Then the feedback controller from eq.(23)\r\n+% ctrl.v=@(t,q,p) (-inv(dphidep(p,t))*Lambda(q,p,t)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p,t))*dphideq(q,t))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+% %ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+% %ctrl.v=@(t,q,p) zeros(6,1);\r\n+% %input u from eq.(20)\r\n+% ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p));\r\n+\r\n+% % Define  closed-loop energy in eq.(24)\r\n+% ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+% ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+% ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729840174807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,20 +7,20 @@\n syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n q_sym = [q1 q2 q3 q4 q5 q6].';\r\n p_sym = [p1 p2 p3 p4 p5 p6].';\r\n \r\n-\r\n ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n \r\n ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n ctrl.D = @(q) sys.D(q);\r\n ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n \r\n % Compute the target momentum from (13)\r\n %期望动量的坐标变换\r\n ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n \r\n-% Compute the error coordinates on q, p from (11), (15) \r\n+% Compute the error coordinates on q, p from (11), (15)\r\n %速度和动量误差\r\n ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n % Compute the gradient of the reference momentum with respect to\r\n@@ -28,21 +28,19 @@\n %求期望动量的梯度\r\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n-%K=tril(ones(6));\r\n-beta = 10000;\r\n+ %K=tril(ones(6));\r\n+ K=diag([500000;500000;500000;500000;500000;500000]);\r\n+ K2=diag([500;500;500;500;500;300]);\r\n+beta = 100000;\r\n gamma = 3;\r\n delta = 1;\r\n-alpha =  diag([50000;50000;50000;50000;50000;50000]);\r\n- K2=diag([500;500;500;500;500;300]);\r\n-eposlion=10;\r\n-% ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n-ctrl.phi = @(t,q,p) K2*ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n- %phi=@(q,p) K*q+tan(p);\r\n+ctrl.phi=@(t,q,p) K*ctrl.eq(t,q)+K2*ctrl.ep(t,q,p)+ beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n %Take a partial derivative of \\phi\r\n-dphideq=matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep=matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n    K3 = diag([5;5;5;5;5;5]);\r\n@@ -66,95 +64,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-\r\n-\r\n-\r\n-\r\n-% dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym,t_sym});\r\n-% dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n-% %Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-% %compute the Lambda from eq.(22)\r\n-% he=sym(0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-% %he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\n-% Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n-% %\r\n-% %Compute the partial derivative of U\r\n-% normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-% %Then the feedback controller from eq.(23)\r\n-% ctrl.v=@(t,q,p) (-inv(dphidep(p,t))*Lambda(q,p,t)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p,t))*dphideq(q,t))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-% %ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-% %ctrl.v=@(t,q,p) zeros(6,1);\r\n-% %input u from eq.(20)\r\n-% ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p));\r\n-\r\n-% % Define  closed-loop energy in eq.(24)\r\n-% ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-% ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-% ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-%Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15) \r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n-%K=tril(ones(6));\r\n-beta = 100000;\r\n-gamma = 3;\r\n-delta = 1;\r\n-alpha =  diag([100000;100000;100000;100000;100000;100000]);\r\n-eposlion=10;\r\n-% ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\n-ctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n- %phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym,t_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-he=sym(0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-%he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n-%\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-ctrl.v=@(t,q,p) (-inv(dphidep(p,t))*Lambda(q,p,t)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p,t))*dphideq(q,t))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-%ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-%ctrl.v=@(t,q,p) zeros(6,1);\r\n-%input u from eq.(20)\r\n-ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p));\r\n-\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729840228807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,15 +48,15 @@\n   Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n \r\n he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{p_sym}]);\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n %Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n % ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n  % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1729840539196,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n+ K2=diag([500;500;500;500;500;300]);\r\n+beta = 100000;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) K*ctrl.eq(t,q) + alpha*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   K3 = diag([5;5;5;5;5;5]);\r\n+    % K3 = diag([0;0;0;0;0;0]);\r\n+  Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n+\r\n+he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+ % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729840578753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,13 +30,13 @@\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n  alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n- K2=diag([500;500;500;500;500;300]);\r\n+ K=diag([500;500;500;500;500;300]);\r\n beta = 100000;\r\n gamma = 3;\r\n delta = 1;\r\n-ctrl.phi=@(t,q,p) K*ctrl.eq(t,q) + alpha*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n %Take a partial derivative of \\phi\r\n dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n"
                },
                {
                    "date": 1729842625284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n  alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n  K=diag([500;500;500;500;500;300]);\r\n-beta = 100000;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n@@ -64,71 +64,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- K=diag([500000;500000;500000;500000;500000;500000]);\r\n- K2=diag([500;500;500;500;500;300]);\r\n-beta = 100000;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) K*ctrl.eq(t,q)+K2*ctrl.ep(t,q,p)+ beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   K3 = diag([5;5;5;5;5;5]);\r\n-    % K3 = diag([0;0;0;0;0;0]);\r\n-  Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n-\r\n-he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n- % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729842691242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,66 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n+beta =diag([500000;500000;500000;500000;500000;500000]);\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   K3 = diag([5;5;5;5;5;5]);\r\n+    % K3 = diag([0;0;0;0;0;0]);\r\n+  Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n+\r\n+he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+% ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+ % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1729842914566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,76 +30,10 @@\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n  alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n-beta =diag([500000;500000;500000;500000;500000;500000]);\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   K3 = diag([5;5;5;5;5;5]);\r\n-    % K3 = diag([0;0;0;0;0;0]);\r\n-  Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n-\r\n-he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n- % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n  K=diag([500;500;500;500;500;300]);\r\n- alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n+beta = diag([500000;500000;500000;500000;500000;500000]);\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1729843003706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n  alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n  K=diag([500;500;500;500;500;300]);\r\n-beta = diag([500000;500000;500000;500000;500000;500000]);\r\n+beta = 10000;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1731722045825,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,10 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n- K=diag([500;500;500;500;500;300]);\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n@@ -42,25 +42,25 @@\n dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n-   K3 = diag([5;5;5;5;5;5]);\r\n-    % K3 = diag([0;0;0;0;0;0]);\r\n-  Kd =@(t,q) K3 + 5*(gbellmf(ctrl.eq(t,q),[2.5,3,0])).*K3;\r\n-\r\n+     K3 = diag([5;5;5;5;5;5]);\r\n+     % K3 = diag([0;0;0;0;0;0]);\r\n+    ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+ % ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n %Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-% ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n- % ctrl.v=@(t,q,p) 0;\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-Kd(t,q)*ctrl.ep(t,q,p));\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n"
                },
                {
                    "date": 1731722197457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,10 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.01;\r\n+ K=diag([500;500;500;500;500;300])*0.01;\r\n beta = 10000;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n"
                },
                {
                    "date": 1731722242729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,10 +29,10 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.01;\r\n- K=diag([500;500;500;500;500;300])*0.01;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n+ K=diag([500;500;500;500;500;300]);\r\n beta = 10000;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n"
                },
                {
                    "date": 1731722292890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000]);\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.5;\r\n  K=diag([500;500;500;500;500;300]);\r\n beta = 10000;\r\n gamma = 3;\r\n delta = 1;\r\n"
                },
                {
                    "date": 1731722302065,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.5;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n  K=diag([500;500;500;500;500;300]);\r\n beta = 10000;\r\n gamma = 3;\r\n delta = 1;\r\n"
                },
                {
                    "date": 1731722341367,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,10 +30,10 @@\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n  alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300]);\r\n-beta = 10000;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1731722484241,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([50000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+     K3 = diag([5;5;5;5;5;5]);\r\n+     % K3 = diag([0;0;0;0;0;0]);\r\n+    ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+ % ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732425729830,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,75 +29,8 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([50000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-     K3 = diag([5;5;5;5;5;5]);\r\n-     % K3 = diag([0;0;0;0;0;0]);\r\n-    ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n- % ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n  alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.1;\r\n gamma = 3;\r\n"
                },
                {
                    "date": 1732425772527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+      K3 = diag([0;0;0;0;0;0]);\r\n+    ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+ % ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732426296725,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,10 +43,10 @@\n %Replace the variable to be determined q with eq(\\tilde \\q)\r\n \r\n %compute the Lambda from eq.(22)\r\n    %   K3 = diag([5;5;5;5;5;5]);\r\n-      K3 = diag([0;0;0;0;0;0]);\r\n-    ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+   %    K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n  % ctrl.Kd = @(t,q) K3;\r\n he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n \r\n Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n@@ -64,71 +64,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-     K3 = diag([5;5;5;5;5;5]);\r\n-     % K3 = diag([0;0;0;0;0;0]);\r\n-    ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n- % ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732455255288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732504261718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ alpha=diag([5000000;500000;500000;500000;500000;500000])*0.1;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.1;\r\n gamma = 3;\r\n delta = 1;\r\n@@ -64,71 +64,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-   %    K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n- % ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732520770034,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([5000000;500000;500000;500000;500000;500000])*0.1;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n beta = 10000*0.1;\r\n gamma = 3;\r\n delta = 1;\r\n"
                },
                {
                    "date": 1732713934139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732714034831,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732714326952,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,11 +29,11 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.5;\r\n+ K=diag([500;500;500;500;500;300])*0.5;\r\n+beta = 10000*0.5;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n@@ -64,138 +64,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732770796723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,11 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+mu= 0.5;\r\n+dUdPhi = matlabFunction((2-mu)*abs(ctrl.phi(t_sym,q_sym,p_sym))^(1-mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu)*abs(ctrl.phi(t_sym,q_sym,p_sym))^(1+mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)));\r\n+%dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n"
                },
                {
                    "date": 1732770819945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,69 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.5;\r\n+ K=diag([500;500;500;500;500;300])*0.5;\r\n+beta = 10000*0.5;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.5;\r\n+dUdPhi = matlabFunction((2-mu)*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu)*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)));\r\n+%dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732770841640,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu)*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu)*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)));\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)));\r\n %dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n@@ -66,73 +66,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.5;\r\n- K=diag([500;500;500;500;500;300])*0.5;\r\n-beta = 10000*0.5;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu)*abs(ctrl.phi(t_sym,q_sym,p_sym))^(1-mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu)*abs(ctrl.phi(t_sym,q_sym,p_sym))^(1+mu)*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)));\r\n-%dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732770928762,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)));\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n %dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732771029186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,11 +29,11 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.5;\r\n- K=diag([500;500;500;500;500;300])*0.5;\r\n-beta = 10000*0.5;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.2;\r\n+ K=diag([500;500;500;500;500;300])*0.2;\r\n+beta = 10000*0.2;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1732771073119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,11 +29,11 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.2;\r\n- K=diag([500;500;500;500;500;300])*0.2;\r\n-beta = 10000*0.2;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.1;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1732771178630,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,11 +29,11 @@\n ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n %% Define Passivity-based sliding mode controller\r\n %VI. NUMERICAL EXAMPLE Case1 and K\r\n  %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.1;\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n  K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.1;\r\n+beta = 10000*0.05;\r\n gamma = 3;\r\n delta = 1;\r\n ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n %phi=@(q,p) K*q+tan(p);\r\n"
                },
                {
                    "date": 1732771480864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,10 +53,10 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+(1+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*sign(ctrl.phi(t_sym,q_sym,p_sym))+sign(ctrl.phi(t_sym,q_sym,p_sym)),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-%dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))+(1+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))+(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n"
                },
                {
                    "date": 1732771766951,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))+(1+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))+(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732771781258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+(ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732772287005,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.5;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+(2+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732772336083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.5;\r\n+mu= 0.3;\r\n dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+(2+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732772478829,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.3;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+(2+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732772497556,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.3;\r\n-dUdPhi = matlabFunction((2+mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732773591857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,14 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.3;\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+p_i = 0.5;\r\n+m_i = 0.5;\r\n+k4 = diag([2;2;2;2;2;2]);\r\n+k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n       ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n@@ -64,6 +69,6 @@\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.U=matlabFunction(abs()+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732773658997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,6 +69,6 @@\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(abs()+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.U=matlabFunction(abs(normPhi).^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732773676550,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,6 +69,6 @@\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(abs(normPhi).^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.U=matlabFunction(abs(normPhi).^(2-mu)+k4*(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732774235587,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,6 +69,6 @@\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(abs(normPhi).^(2-mu)+k4*(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+k4*(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732774621160,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -69,6 +69,6 @@\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n % ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+k4*(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732774835802,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n mu= 0.3;\r\n p_i = 0.5;\r\n m_i = 0.5;\r\n k4 = diag([2;2;2;2;2;2]);\r\n-k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym))\r\n \r\n dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n"
                },
                {
                    "date": 1732779061061,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n \r\n dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-      ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732799406348,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n m_i = 0.5;\r\n k4 = diag([2;2;2;2;2;2]);\r\n k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym))\r\n \r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732799431653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.3;\r\n+p_i = 0.5;\r\n+m_i = 0.5;\r\n+k4 = diag([2;2;2;2;2;2]);\r\n+k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732799714654,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n m_i = 0.5;\r\n k4 = diag([2;2;2;2;2;2]);\r\n k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n@@ -71,78 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.3;\r\n-p_i = 0.5;\r\n-m_i = 0.5;\r\n-k4 = diag([2;2;2;2;2;2]);\r\n-k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym))\r\n-\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732844617089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.3;\r\n+p_i = 0.5;\r\n+m_i = 0.5;\r\n+k4 = diag([2;2;2;2;2;2]);\r\n+k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732844622941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,12 +53,12 @@\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n mu= 0.3;\r\n-p_i = 0.5;\r\n-m_i = 0.5;\r\n-k4 = diag([2;2;2;2;2;2]);\r\n-k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+% k4 = diag([2;2;2;2;2;2]);\r\n+% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n@@ -71,78 +71,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.3;\r\n-p_i = 0.5;\r\n-m_i = 0.5;\r\n-k4 = diag([2;2;2;2;2;2]);\r\n-k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n-\r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732848561739,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,11 @@\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction((2-mu).*abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n+  + abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n++2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732848670492,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.3;\r\n+mu= 0.2;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n"
                },
                {
                    "date": 1732848703322,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.2;\r\n+mu= 0.5;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n"
                },
                {
                    "date": 1732848859848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.5;\r\n+mu= 0.4;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n"
                },
                {
                    "date": 1732848882116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.4;\r\n+mu= 0.1;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n"
                },
                {
                    "date": 1732848988263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,10 +59,9 @@\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-  + abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1+mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-+2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+                        +2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732869877305,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n % passed in via sys and ctrl\r\n % input: sys, ctrl\r\n % output: ctrl\r\n function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n q_sym = [q1 q2 q3 q4 q5 q6].';\r\n p_sym = [p1 p2 p3 p4 p5 p6].';\r\n \r\n ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n@@ -59,12 +59,12 @@\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +2*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+                        +((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732869921461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,9 +62,9 @@\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n                         +((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n    % ctrl.v=@(t,q,p) 0;\r\n %input u from eq.(20)\r\n  ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732871301857,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,75 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.1;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+% k4 = diag([2;2;2;2;2;2]);\r\n+% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n+                        +k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732871334286,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n+                        +k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[k4,{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n@@ -72,79 +72,4 @@\n % Define  closed-loop energy in eq.(24)\r\n ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n-%% This script defines the TSMC controller, and its generated energy function.\r\n-% Defined matrices of related symbols such as masses or trajectories, \r\n-% passed in via sys and ctrl\r\n-% input: sys, ctrl\r\n-% output: ctrl\r\n-function [ctrl]=TSMCController(sys,ctrl)\r\n-syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n-q_sym = [q1 q2 q3 q4 q5 q6].';\r\n-p_sym = [p1 p2 p3 p4 p5 p6].';\r\n-\r\n-ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n-\r\n-ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n-ctrl.D = @(q) sys.D(q);\r\n-ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n-% Define target trajectory and derivatives\r\n-\r\n-% Compute the target momentum from (13)\r\n-%期望动量的坐标变换\r\n-ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n-\r\n-% Compute the error coordinates on q, p from (11), (15)\r\n-%速度和动量误差\r\n-ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n-ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n-% Compute the gradient of the reference momentum with respect to\r\n-% configuration as per (16)\r\n-%求期望动量的梯度\r\n-ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n-%% Define Passivity-based sliding mode controller\r\n-%VI. NUMERICAL EXAMPLE Case1 and K\r\n- %K=tril(ones(6));\r\n- alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n- K=diag([500;500;500;500;500;300])*0.1;\r\n-beta = 10000*0.05;\r\n-gamma = 3;\r\n-delta = 1;\r\n-ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n-%phi=@(q,p) K*q+tan(p);\r\n-%Take a partial derivative of \\phi\r\n-dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n-dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n-%Replace the variable to be determined q with eq(\\tilde \\q)\r\n-\r\n-%compute the Lambda from eq.(22)\r\n-   %   K3 = diag([5;5;5;5;5;5]);\r\n-       K3 = diag([0;0;0;0;0;0]);\r\n-   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n-  ctrl.Kd = @(t,q) K3;\r\n-he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n-\r\n-Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n-\r\n-%Compute the partial derivative of U\r\n-normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.1;\r\n-% p_i = 0.5;\r\n-% m_i = 0.5;\r\n-% k4 = diag([2;2;2;2;2;2]);\r\n-% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n-\r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n-% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n-%Then the feedback controller from eq.(23)\r\n-   ctrl.v=@(t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n-%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n-   % ctrl.v=@(t,q,p) 0;\r\n-%input u from eq.(20)\r\n- ctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n-% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n-% Define  closed-loop energy in eq.(24)\r\n-ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n-ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n-ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                },
                {
                    "date": 1732871354572,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[k4,{t_sym},{q_sym},{p_sym}]);\r\n+                        +k4.*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[k4,{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732871473396,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +k4.*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[k4,{t_sym},{q_sym},{p_sym}]);\r\n+                        +k4.*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732871519594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +k4.*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+                        +k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732872155290,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,10 +58,9 @@\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))...\r\n-                        +k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732955132833,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,15 +52,15 @@\n Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n \r\n %Compute the partial derivative of U\r\n normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n-mu= 0.1;\r\n+mu= 0.6;\r\n % p_i = 0.5;\r\n % m_i = 0.5;\r\n % k4 = diag([2;2;2;2;2;2]);\r\n % k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n \r\n-dUdPhi = matlabFunction(k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu)*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n % dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n %Then the feedback controller from eq.(23)\r\n    ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n %   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n"
                },
                {
                    "date": 1732955152534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+%% This script defines the TSMC controller, and its generated energy function.\r\n+% Defined matrices of related symbols such as masses or trajectories, \r\n+% passed in via sys and ctrl\r\n+% input: sys, ctrl\r\n+% output: ctrl\r\n+function [ctrl]=TSMCController(sys,ctrl)\r\n+syms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym k4\r\n+q_sym = [q1 q2 q3 q4 q5 q6].';\r\n+p_sym = [p1 p2 p3 p4 p5 p6].';\r\n+\r\n+ctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n+\r\n+ctrl.p = @(q,p) ctrl.T(q)'*p;\r\n+ctrl.D = @(q) sys.D(q);\r\n+ctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n+% Define target trajectory and derivatives\r\n+\r\n+% Compute the target momentum from (13)\r\n+%期望动量的坐标变换\r\n+ctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n+\r\n+% Compute the error coordinates on q, p from (11), (15)\r\n+%速度和动量误差\r\n+ctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\n+ctrl.eq = @(t,q) q - ctrl.qd(t);\r\n+% Compute the gradient of the reference momentum with respect to\r\n+% configuration as per (16)\r\n+%求期望动量的梯度\r\n+ctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n+%% Define Passivity-based sliding mode controller\r\n+%VI. NUMERICAL EXAMPLE Case1 and K\r\n+ %K=tril(ones(6));\r\n+ alpha=diag([500000;500000;500000;500000;500000;500000])*0.05;\r\n+ K=diag([500;500;500;500;500;300])*0.1;\r\n+beta = 10000*0.05;\r\n+gamma = 3;\r\n+delta = 1;\r\n+ctrl.phi=@(t,q,p) alpha*ctrl.eq(t,q) + K*ctrl.ep(t,q,p) + beta.*ctrl.eq(t,q).^(gamma/delta);%Here q is a variable to be determined\r\n+%phi=@(q,p) K*q+tan(p);\r\n+%Take a partial derivative of \\phi\r\n+dphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{t_sym,q_sym});\r\n+dphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym});\r\n+%Replace the variable to be determined q with eq(\\tilde \\q)\r\n+\r\n+%compute the Lambda from eq.(22)\r\n+   %   K3 = diag([5;5;5;5;5;5]);\r\n+       K3 = diag([0;0;0;0;0;0]);\r\n+   %  ctrl.Kd =@(t,q) K3 + 100*(1-gbellmf(ctrl.eq(t,q),[2.5,0.9,0])).*K3;\r\n+  ctrl.Kd = @(t,q) K3;\r\n+he=sym(0.5*(dphideq(t_sym,q_sym)*(ctrl.T(q_sym)))*dphidep(p_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n+\r\n+Lambda=matlabFunction(2*(he+he'),'vars',[{t_sym,q_sym,p_sym}]);\r\n+\r\n+%Compute the partial derivative of U\r\n+normPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\n+mu= 0.6;\r\n+% p_i = 0.5;\r\n+% m_i = 0.5;\r\n+% k4 = diag([2;2;2;2;2;2]);\r\n+% k4 = -p_i*m_i*k4+p_i.*abs(ctrl.phi(t_sym,q_sym,p_sym));\r\n+\r\n+dUdPhi = matlabFunction(abs(ctrl.phi(t_sym,q_sym,p_sym)).^(1-mu).*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))))+k4*((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2)))),'vars',[{k4},{t_sym},{q_sym},{p_sym}]);\r\n+% dUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%base TSMC's energy function  derivative\r\n+%Then the feedback controller from eq.(23)\r\n+   ctrl.v=@(k4,t,q,p) (-inv(dphidep(p))*Lambda(t,q,p)*dUdPhi(k4,t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p))*dphideq(t,q))*(ctrl.T(q)))*ctrl.ep(t,q,p));\r\n+%   ctrl.v=@(t,q,p) -inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q, p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n+   % ctrl.v=@(t,q,p) 0;\r\n+%input u from eq.(20)\r\n+ ctrl.u = @(k4,t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(k4,t,q,p)-ctrl.Kd(t,q)*ctrl.ep(t,q,p));\r\n+% ctrl.u=@(t,q,p) ctrl.G(q)\\(-Kd*p);\r\n+% Define  closed-loop energy in eq.(24)\r\n+ctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\n+ctrl.U=matlabFunction(sum(abs(normPhi))^(2-mu)+(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\n+ctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
                }
            ],
            "date": 1729819406605,
            "name": "Commit-0",
            "content": "%% This script defines the TSMC controller, and its generated energy function.\r\n% input: sys, ctrl\r\n% output: ctrl\r\nfunction [ctrl]=TSMCController(sys,ctrl)\r\nsyms q1 q2 q3 q4 q5 q6 p1 p2 p3 p4 p5 p6 t_sym\r\nq_sym = [q1 q2 q3 q4 q5 q6].';\r\np_sym = [p1 p2 p3 p4 p5 p6].';\r\n\r\nctrl.T =matlabFunction(manualCholesky(inv(sys.M(q_sym))),'vars',{q_sym});\r\n\r\nctrl.p = @(q,p) ctrl.T(q)'*p;\r\nctrl.D = @(q) sys.D(q);\r\nctrl.G = @(q) ctrl.T(q)'*sys.G(q);\r\n\r\n% Compute the target momentum from (13)\r\n%期望动量的坐标变换\r\nctrl.pd = @(t,q) ctrl.T(q)\\ctrl.dqd(t);\r\n\r\n% Compute the error coordinates on q, p from (11), (15) \r\n%速度和动量误差\r\nctrl.ep = @(t,q,p) p - ctrl.pd(t,q);\r\nctrl.eq = @(t,q) q - ctrl.qd(t);\r\n% Compute the gradient of the reference momentum with respect to\r\n% configuration as per (16)\r\n%求期望动量的梯度\r\nctrl.dpddq = matlabFunction(jacobian(ctrl.pd(t_sym,q_sym),q_sym),'vars',[{t_sym}, {q_sym}]);\r\n%% Define Passivity-based sliding mode controller\r\n%VI. NUMERICAL EXAMPLE Case1 and K\r\n%K=tril(ones(6));\r\nbeta = 1;\r\ngamma = 3;\r\ndelta = 1;\r\nalpha =  diag([500;500;500;500;500;500]);\r\neposlion=10;\r\n% ctrl.phi=@(t,q,p) (K*ctrl.eq(t,q)+ctrl.ep(t,q,p));%Here q is a variable to be determined\r\nctrl.phi = @(t,q,p) ctrl.ep(t,q,p) + alpha*ctrl.eq(t,q) + beta.*ctrl.eq(t,q).^(gamma/delta);\r\n %phi=@(q,p) K*q+tan(p);\r\n%Take a partial derivative of \\phi\r\ndphideq = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),q_sym),'vars',{q_sym,t_sym});\r\ndphidep = matlabFunction(jacobian(ctrl.phi(t_sym,q_sym,p_sym),p_sym),'vars',{p_sym,t_sym});\r\n%Replace the variable to be determined q with eq(\\tilde \\q)\r\n\r\n%compute the Lambda from eq.(22)\r\nhe=sym(500*0.5*(dphideq(q_sym,t_sym)*ctrl.T(q_sym))*dphidep(p_sym,t_sym)');%这里的系数对系统收敛到滑模面上有影响\r\n%he=100000*0.5*(dphidq(q_sym)*ctrl.T(q_sym))*dphidep(t_sym,q_sym,p_sym)';\r\nLambda=matlabFunction(2*(he+he'),'vars',[{q_sym,p_sym,t_sym}]);\r\n%\r\n%Compute the partial derivative of U\r\nnormPhi=ctrl.phi(t_sym,q_sym,p_sym);\r\ndUdPhi=matlabFunction((ctrl.phi(t_sym,q_sym,p_sym))/(sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);\r\n%Then the feedback controller from eq.(23)\r\nctrl.v=@(t,q,p) (-inv(dphidep(p,t))*Lambda(q,p,t)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(p,t))*dphideq(q,t))*ctrl.T(q))*ctrl.ep(t,q,p));\r\n%ctrl.v=@(t,q,p) (-inv(dphidep(t,q,p))*Lambda(t,q,p)*dUdPhi(t,q,p)+(ctrl.D(q))*ctrl.ep(t,q,p)-((inv(dphidep(t,q,p))*dphidq())*ctrl.T(q))*ctrl.ep(t,q,p));\r\n%ctrl.v=@(t,q,p) zeros(6,1);\r\n%input u from eq.(20)\r\nctrl.u = @(t,q,p) ctrl.G(q)\\(ctrl.D(q)*ctrl.pd(t,q) + ctrl.dpddq(t,q)*(ctrl.T(q)*p) + ctrl.T(q)\\ctrl.ddqd(t) + ctrl.T(q)'*sys.dVdq(q) + ctrl.v(t,q,p));\r\n\r\n% Define  closed-loop energy in eq.(24)\r\nctrl.KE = @(t,q,p) 0.5*sum(ctrl.ep(t,q,p).^2);%kinetic energy\r\nctrl.U=matlabFunction((sqrt(sum(normPhi.^2))),'vars',[{t_sym},{q_sym},{p_sym}]);%potential energy\r\nctrl.Hd = @(t,q,p) ctrl.KE(t,q,p) + ctrl.U(t,q,p);\r\n"
        }
    ]
}